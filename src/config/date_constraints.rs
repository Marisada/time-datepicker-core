use derive_builder::Builder;
use std::collections::HashSet;
use time::{Date, Month, PrimitiveDateTime, Weekday};

use crate::{
    utils::from_ymdhm,
    viewed_date::{ViewedDate, year_group_range},
};

#[cfg(test)]
use mockall::automock;

/// Trait that can be implemented to create your own date constraints.
#[cfg_attr(test, automock)]
pub trait HasDateConstraints {
    /// Returns true if the given date is forbidden.
    fn is_day_forbidden(&self, date: &PrimitiveDateTime) -> bool;

    /// Returns true if the entire month described by year_month_info is forbidden.
    fn is_month_forbidden(&self, year_month_info: &PrimitiveDateTime) -> bool;

    /// Returns true if the entire given year is forbidden.
    fn is_year_forbidden(&self, year: &PrimitiveDateTime) -> bool;

    /// Returns true if the entire group of years including the given year is forbidden.
    /// A group of years are inclusive intervals [1980, 1999], [2000, 2019], [2020, 2039], ...
    fn is_year_group_forbidden(&self, year: &PrimitiveDateTime) -> bool;
}

/// Date constraints configuration
#[derive(Default, Debug, Clone, Builder)]
#[builder(setter(strip_option))]
#[builder(default)]
#[builder(build_fn(validate = "Self::validate"))]
pub struct DateConstraints {
    /// Inclusive minimal datetime constraint
    /// the earliest datetime that can be selected
    min_datetime: Option<PrimitiveDateTime>,

    /// Inclusive maximal datetime constraint
    /// the latest datetime that can be selected
    max_datetime: Option<PrimitiveDateTime>,

    /// Disabled weekdays, that should not be selectable
    disabled_weekdays: HashSet<Weekday>,

    /// Entire completely disabled months in every year
    disabled_months: HashSet<Month>,

    /// Entire completely disabled years
    disabled_years: HashSet<i32>,

    /// Disabled monthly periodically repeating dates, so it is just a day number
    /// starting from 1 for the first day of the month
    /// if unique dates in a certain year should not be selectable use `disabled_unique_dates`
    disabled_monthly_dates: HashSet<u8>,

    /// Disabled yearly periodically repeating dates that should not be selectable,
    /// if unique dates in a certain year should not be selectable use `disabled_unique_dates`
    /// it is a `Vec` since we need to iterate over it anyway, since we have no MonthDay type
    disabled_yearly_dates: Vec<Date>,

    /// Disabled unique dates with a specific year, month and day that should not be selectable,
    /// if some periodically repeated dates should not be selectable use the correct option
    disabled_unique_dates: HashSet<Date>,
}

impl DateConstraintsBuilder {
    pub fn validate(&self) -> Result<(), String> {
        if let (Some(min_datetime), Some(max_datetime)) = (self.min_datetime, self.max_datetime) {
            if min_datetime > max_datetime {
                return Err("min_datetime must be earlier or exactly at max_datetime".into());
            }
        }
        Ok(())
    }
}

// TODO: find out how to place #[derive(Clone)] on the structure generated by automock
// this is a temporary workaround for tests
cfg_if::cfg_if! {
    if #[cfg(test)] {
        impl Clone for MockHasDateConstraints  {
            fn clone(&self) -> Self {
                Self::new()
            }
        }
    }
}

impl HasDateConstraints for DateConstraints {
    fn is_day_forbidden(&self, datetime: &PrimitiveDateTime) -> bool {
        let date = datetime.date();
        self.min_datetime
            .map_or(false, |min_datetime| &min_datetime > datetime)
            || self
                .max_datetime
                .map_or(false, |max_datetime| &max_datetime < datetime)
            || self.disabled_weekdays.contains(&date.weekday())
            || self.disabled_months.contains(&date.month())
            || self.disabled_years.contains(&date.year())
            || self.disabled_unique_dates.contains(&date)
            || self.disabled_monthly_dates.contains(&date.day())
            || self
                .disabled_yearly_dates
                .iter()
                .any(|disabled| disabled.day() == date.day() && disabled.month() == date.month())
    }

    fn is_month_forbidden(&self, year_month_info: &PrimitiveDateTime) -> bool {
        let date = year_month_info.date();
        self.disabled_years.contains(&date.year())
            || self.disabled_months.contains(&date.month())
            || year_month_info
                .dates_in_month()
                .iter()
                .all(|datetime| self.is_day_forbidden(&datetime))
    }

    fn is_year_forbidden(&self, year: &PrimitiveDateTime) -> bool {
        let date = year.date();
        let time = year.time();
        self.disabled_years.contains(&date.year())
            || (1..=12u8).all(|month| {
                self.is_month_forbidden(&from_ymdhm(
                    date.year(),
                    month,
                    date.day(),
                    time.hour(),
                    time.minute(),
                ))
            })
    }

    fn is_year_group_forbidden(&self, year: &PrimitiveDateTime) -> bool {
        let date = year.date();
        let time = year.time();
        year_group_range(date.year()).all(|year| {
            self.is_year_forbidden(&from_ymdhm(
                year,
                date.month() as u8,
                date.day(),
                time.hour(),
                time.minute(),
            ))
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        rstest_utils::create_datetime,
        utils::from_ymd,
        viewed_date::{DayNumber, MonthNumber, YearNumber},
    };
    use rstest::*;
    use time::{Duration, Time};

    #[rstest(
        tested_date,
        case(create_datetime(1, 12, 25, 0, 0)),
        case(create_datetime(3000, 3, 22, 0, 0))
    )]
    fn is_day_forbidden_default_no_bounds(tested_date: PrimitiveDateTime) {
        assert!(!DateConstraints::default().is_day_forbidden(&tested_date))
    }

    #[rstest(
        tested_date,
        case(create_datetime(1, 12, 25, 0, 0)),
        case(create_datetime(3000, 3, 22, 0, 0))
    )]
    fn is_month_forbidden_default_no_bounds(tested_date: PrimitiveDateTime) {
        assert!(!DateConstraints::default().is_month_forbidden(&tested_date))
    }

    #[rstest(
        tested_year,
        case(create_datetime(1, 12, 25, 0, 0)),
        case(create_datetime(3000, 3, 22, 0, 0))
    )]
    fn is_year_forbidden_default_no_bounds(tested_year: PrimitiveDateTime) {
        assert!(!DateConstraints::default().is_year_forbidden(&tested_year))
    }

    #[test]
    fn picker_config_min_date_greater_than_max_date() {
        let datetime = from_ymdhm(2020, 10, 15, 0, 0);
        let config = DateConstraintsBuilder::default()
            .min_datetime(datetime.clone())
            .max_datetime(datetime.clone() - Duration::days(1))
            .build();
        assert!(config.is_err());
        assert_eq!(
            config.unwrap_err().to_string(),
            "min_datetime must be earlier or exactly at max_datetime"
        );
    }

    #[test]
    fn picker_config_min_date_equals_max_date() {
        let datetime = from_ymdhm(2020, 10, 15, 0, 0);
        let config = DateConstraintsBuilder::default()
            .min_datetime(datetime.clone())
            .max_datetime(datetime.clone())
            .build();
        assert!(config.is_ok());
    }

    #[test]
    fn is_day_forbidden_at_min_date_allowed() {
        let datetime = from_ymdhm(2020, 10, 15, 0, 0);
        let config = DateConstraintsBuilder::default()
            .min_datetime(datetime.clone())
            .build()
            .unwrap();
        assert!(!config.is_day_forbidden(&datetime))
    }

    #[test]
    fn is_day_forbidden_before_min_date_not_allowed() {
        let datetime = from_ymdhm(2020, 10, 15, 0, 0);
        let config = DateConstraintsBuilder::default()
            .min_datetime(datetime.clone())
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&(datetime - Duration::days(1))))
    }

    #[test]
    fn is_day_forbidden_at_max_date_allowed() {
        let datetime = from_ymdhm(2020, 10, 15, 0, 0);
        let config = DateConstraintsBuilder::default()
            .max_datetime(datetime.clone())
            .build()
            .unwrap();
        assert!(!config.is_day_forbidden(&datetime))
    }

    #[test]
    fn is_day_forbidden_after_max_date_not_allowed() {
        let datetime = from_ymdhm(2020, 10, 15, 0, 0);
        let config = DateConstraintsBuilder::default()
            .max_datetime(datetime.clone())
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&(datetime + Duration::days(1))))
    }

    #[rstest(
        year => [1, 2000, 3000],
        week => [1, 25, 51],
        disabled_weekday => [Weekday::Monday, Weekday::Tuesday, Weekday::Saturday],
    )]
    fn is_day_forbidden_disabled_weekday_not_allowed(
        year: YearNumber,
        week: u8,
        disabled_weekday: Weekday,
    ) {
        let config = DateConstraintsBuilder::default()
            .disabled_weekdays([disabled_weekday].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&PrimitiveDateTime::new(
            Date::from_iso_week_date(year, week, disabled_weekday).expect("invalid date"),
            Time::from_hms(0, 0, 0).expect("invalid time"),
        )));
    }

    #[rstest(
        year => [1, 2000, 3000],
        disabled_month => [Month::January, Month::July, Month::December],
        day => [1, 15, 27],
    )]
    fn is_day_forbidden_disabled_month_not_allowed(
        year: YearNumber,
        disabled_month: Month,
        day: DayNumber,
    ) {
        let config = DateConstraintsBuilder::default()
            .disabled_months([disabled_month].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&from_ymdhm(year, disabled_month as u8, day, 0, 0)))
    }

    #[rstest(
        disabled_year => [1, 2000, 3000],
        month => [1, 7, 12],
        day => [1, 15, 27],
    )]
    fn is_day_forbidden_disabled_year_not_allowed(
        disabled_year: YearNumber,
        month: MonthNumber,
        day: DayNumber,
    ) {
        let config = DateConstraintsBuilder::default()
            .disabled_years([disabled_year].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&from_ymdhm(disabled_year, month, day, 0, 0)))
    }

    #[test]
    fn is_day_forbidden_disabled_unique_dates_not_allowed() {
        let date = from_ymdhm(2020, 1, 16, 0, 0);
        let config = DateConstraintsBuilder::default()
            .disabled_unique_dates([date.date()].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&date))
    }

    #[test]
    fn is_day_forbidden_disabled_unique_dates_after_a_year_allowed() {
        let date = from_ymd(2020, 1, 16);
        let config = DateConstraintsBuilder::default()
            .disabled_unique_dates([date].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(!config.is_day_forbidden(&from_ymdhm(2021, 1, 16, 0, 0)))
    }

    #[rstest(
        year_in_disabled => [1, 2000, 3000],
        year_in_input => [1, 1500, 2000],
        month => [1, 7, 12],
        day => [1, 15, 27],
    )]
    fn is_day_forbidden_disabled_yearly_dates_not_allowed(
        year_in_disabled: YearNumber,
        year_in_input: YearNumber,
        month: MonthNumber,
        day: DayNumber,
    ) {
        let disabled_yearly_date = from_ymd(year_in_disabled, month, day);
        let config = DateConstraintsBuilder::default()
            .disabled_yearly_dates(vec![disabled_yearly_date])
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&from_ymdhm(year_in_input, month, day, 0, 0)))
    }

    #[rstest(
        year => [1, 2000, 3000],
        month => [1, 7, 12],
        day => [1, 15, 27],
    )]
    fn is_day_forbidden_disabled_monthly_dates_not_allowed(
        year: YearNumber,
        month: MonthNumber,
        day: DayNumber,
    ) {
        let config = DateConstraintsBuilder::default()
            .disabled_monthly_dates([day].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(config.is_day_forbidden(&from_ymdhm(year, month, day, 0, 0)))
    }

    #[rstest(
        year => [1, 2000, 3000],
        disabled_month => [Month::January, Month::July, Month::December],
        day => [1, 15, 27],
    )]
    fn is_month_forbidden_disabled_months_not_allowed(
        year: YearNumber,
        disabled_month: Month,
        day: DayNumber,
    ) {
        let config = DateConstraintsBuilder::default()
            .disabled_months([disabled_month].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(config.is_month_forbidden(&from_ymdhm(year, disabled_month as u8, day, 0, 0)))
    }

    #[rstest(
        disabled_year => [1, 2000, 3000],
        month => [1, 7, 12],
        day => [1, 15, 27],
    )]
    fn is_month_forbidden_disabled_years_not_allowed(
        disabled_year: YearNumber,
        month: MonthNumber,
        day: DayNumber,
    ) {
        let config = DateConstraintsBuilder::default()
            .disabled_years([disabled_year].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(config.is_month_forbidden(&from_ymdhm(disabled_year, month, day, 0, 0)))
    }

    #[rstest(
        disabled_year => [1, 2000, 3000],
    )]
    fn is_year_forbidden_disabled_years_not_allowed(disabled_year: YearNumber) {
        let config = DateConstraintsBuilder::default()
            .disabled_years([disabled_year].iter().cloned().collect())
            .build()
            .unwrap();
        assert!(config.is_year_forbidden(&from_ymdhm(disabled_year, 1, 1, 0, 0)))
    }

    #[rstest(
        disabled_year_group => [1, 2000, 3000],
    )]
    fn is_year_group_forbidden_disabled_years_not_allowed(disabled_year_group: YearNumber) {
        let config = DateConstraintsBuilder::default()
            .disabled_years(year_group_range(disabled_year_group).collect())
            .build()
            .unwrap();
        assert!(config.is_year_group_forbidden(&from_ymdhm(disabled_year_group, 1, 1, 0, 0)))
    }
}
